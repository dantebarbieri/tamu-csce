# Quicksort
## Video
https://youtu.be/__3Xw4-t454

## Description
Quicksort picks a partition element (we choose the end, but you can select the start, the middle, or even a random element) and then moves all values in the subarray that are less than the partition to its left and all values greater to its right. It repeatedly does this until there are no more partitions to choose from because the array is sorted.

The sorting comes from the `partition` function, whose job is to take in the list and divide it into two lists where the left list is less than the pivot and the right list is greater than the pivot.

All `quick_sort` does is call `partition` to vaguely sort the list and then to recursively call itself with two sublists being the left and right lists generated by partition.

## Analysis
The efficiency depends on where the partition is chosen and varies by the content of the lists.

In the best case, Quick Sort is just as fast as Merge Sort because the pivots act like Merge Sort splitting the list into two parts equally sortable at every stage.

In the worst case, Quick Sort shifts everything to the other side of the pivot repeatedly until the list is sorted, which is very inefficient and takes O(n^2) time.

Its advantage over Merge Sort is that its worst-case space complexity is O(log n) to Merge Sort's O(n).